<!doctype html>
<html lang="ar">
<head>
  <meta charset="utf-8" />
  <title>Anah Digital Twin</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#eef1f5; font-family: Arial, sans-serif; }
    #c { display:block; width:100%; height:100%; }

    #hud{
      position:fixed; left:50%; top:14px; transform:translateX(-50%);
      z-index:9999; background:rgba(0,0,0,.72); color:#fff;
      padding:10px 14px; border-radius:10px; font-size:14px;
      max-width:92vw; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
      display:flex; align-items:center; gap:10px;
    }
    #barWrap{ width:220px; height:8px; background:rgba(255,255,255,.22); border-radius:999px; overflow:hidden; }
    #bar{ height:100%; width:0%; background:#7dd3fc; }

    #reset{
      position:fixed; top:14px; right:14px; z-index:9999;
      border:0; border-radius:10px; background:#1d4ed8; color:#fff;
      padding:10px 14px; cursor:pointer; font-weight:700;
      box-shadow:0 8px 24px rgba(0,0,0,.18);
    }

    #err{
      position:fixed; left:14px; right:14px; bottom:14px; z-index:9999;
      display:none; background:rgba(255,255,255,.97);
      border:1px solid #e5e7eb; border-radius:12px; padding:12px 14px;
      font-size:13px; color:#111827;
    }
    #err b{ color:#b00020; }
    code{ background:#f3f4f6; padding:2px 6px; border-radius:6px; }
  </style>
</head>

<body>
  <canvas id="c"></canvas>

  <div id="hud">
    <span id="hudText">⏳ Loading model...</span>
    <div id="barWrap"><div id="bar"></div></div>
  </div>

  <button id="reset" title="Reset view">⟳ Reset</button>
  <div id="err"></div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
    import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";
    import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/GLTFLoader.js";

    const canvas = document.getElementById("c");
    const hud = document.getElementById("hud");
    const hudText = document.getElementById("hudText");
    const bar = document.getElementById("bar");
    const errBox = document.getElementById("err");
    const resetBtn = document.getElementById("reset");

    function showError(title, details) {
      errBox.style.display = "block";
      errBox.innerHTML = `<b>Error:</b> ${title}<br><div style="margin-top:6px">${details || ""}</div>`;
      hudText.textContent = "❌ Failed";
      bar.style.width = "0%";
    }

    // ===== Renderer =====
    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: true,
      alpha: false,
      powerPreference: "high-performance"
    });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setSize(window.innerWidth, window.innerHeight, false);

    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.05;

    // ===== Scene & Camera =====
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xeef1f5);

    const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 5000);
    camera.position.set(12, 10, 18);

    // ===== Controls =====
    let controls;
    try {
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.06;
      controls.enablePan = true;
      controls.screenSpacePanning = true;
      controls.minDistance = 1;
      controls.maxDistance = 800;
      controls.maxPolarAngle = Math.PI * 0.495;
      controls.target.set(0, 0, 0);
      controls.update();
    } catch (e) {
      showError("OrbitControls failed", `<code>${String(e)}</code>`);
      throw e;
    }

    // ===== Lights =====
    scene.add(new THREE.AmbientLight(0xffffff, 0.55));
    const sun = new THREE.DirectionalLight(0xffffff, 1.15);
    sun.position.set(40, 70, 25);
    scene.add(sun);
    const fill = new THREE.DirectionalLight(0xffffff, 0.35);
    fill.position.set(-30, 25, -20);
    scene.add(fill);

    // Ground
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(3000, 3000),
      new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.95, metalness: 0.0 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0;
    scene.add(ground);

    const loader = new GLTFLoader();

    let modelRoot = null;
    let defaultCam = null;
    let defaultTarget = null;

    function frameObject(obj) {
      const box = new THREE.Box3().setFromObject(obj);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());

      const target = center.clone();
      target.y = Math.max(center.y, 0);

      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = THREE.MathUtils.degToRad(camera.fov);
      let dist = (maxDim * 0.75) / Math.tan(fov / 2);
      dist *= 1.25;

      const dir = new THREE.Vector3(1, 0.7, 1).normalize();
      const pos = target.clone().add(dir.multiplyScalar(dist));

      camera.near = Math.max(0.1, dist / 200);
      camera.far = Math.max(2000, dist * 8);
      camera.updateProjectionMatrix();

      camera.position.copy(pos);
      controls.target.copy(target);
      controls.update();

      defaultCam = camera.position.clone();
      defaultTarget = controls.target.clone();
    }

    // ===== Robust loader (tries multiple names + shows clear errors) =====
    const CANDIDATES = [
      "./Anahcity2_0.glb",
      "./AnahCity2_0.glb",
      "./anahcity2_0.glb",
      "./Anahcity2_0.GLB",
      "./AnahCity2_0.GLB",
      "./Anahcity2-0.glb",
      "./Anahcity2.glb"
    ];

    async function fetchArrayBuffer(url, onProgress) {
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error(`HTTP ${res.status} (${res.statusText})`);

      const total = Number(res.headers.get("content-length") || 0);

      if (!res.body || !("getReader" in res.body)) {
        const buf = await res.arrayBuffer();
        onProgress?.(buf.byteLength, buf.byteLength);
        return buf;
      }

      const reader = res.body.getReader();
      let loaded = 0;
      const chunks = [];

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        chunks.push(value);
        loaded += value.byteLength;
        onProgress?.(loaded, total);
      }

      const out = new Uint8Array(loaded);
      let offset = 0;
      for (const c of chunks) {
        out.set(c, offset);
        offset += c.byteLength;
      }
      return out.buffer;
    }

    async function loadModelSmart() {
      let lastErr = null;

      for (const url of CANDIDATES) {
        try {
          hudText.textContent = `⏳ Loading: ${url.replace("./","")}`;
          bar.style.width = "5%";

          const buf = await fetchArrayBuffer(url, (loaded, total) => {
            if (total > 0) {
              const p = Math.min(99, Math.round((loaded / total) * 100));
              hudText.textContent = `⏳ Loading... ${p}%`;
              bar.style.width = `${p}%`;
            } else {
              // بدون content-length
              hudText.textContent = "⏳ Loading...";
              bar.style.width = "35%";
            }
          });

          bar.style.width = "60%";
          const gltf = await new Promise((resolve, reject) => {
            loader.parse(
              buf,
              "./",
              resolve,
              reject
            );
          });

          modelRoot = gltf.scene;

          modelRoot.traverse((o) => {
            if (o.isMesh) {
              if (o.material) {
                o.material.side = THREE.FrontSide;
                o.material.needsUpdate = true;
              }
            }
          });

          // put on ground
          const box = new THREE.Box3().setFromObject(modelRoot);
          const minY = box.min.y;
          modelRoot.position.y -= minY;

          scene.add(modelRoot);
          frameObject(modelRoot);

          hudText.textContent = "✅ Loaded";
          bar.style.width = "100%";
          setTimeout(() => { hud.style.display = "none"; }, 900);
          return; // success
        } catch (e) {
          lastErr = e;
        }
      }

      showError(
        "GLB not found / failed to load",
        `لم أستطع تحميل أي اسم من هذه الملفات:<br>
         <code>${CANDIDATES.map(x => x.replace("./","")).join("</code>, <code>")}</code><br><br>
         آخر خطأ: <code>${String(lastErr?.message || lastErr)}</code>`
      );
    }

    // Timeout safeguard
    const hardTimeout = setTimeout(() => {
      if (!modelRoot) {
        showError("Timeout", "التحميل تجاوز الوقت. غالباً الملف غير موجود أو كبير جداً أو الاسم مختلف.");
      }
    }, 30000);

    loadModelSmart().finally(() => clearTimeout(hardTimeout));

    // ===== Reset =====
    resetBtn.addEventListener("click", () => {
      if (defaultCam && defaultTarget) {
        camera.position.copy(defaultCam);
        controls.target.copy(defaultTarget);
        controls.update();
      } else if (modelRoot) {
        frameObject(modelRoot);
      }
    });

    // ===== Resize =====
    window.addEventListener("resize", () => {
      const w = window.innerWidth, h = window.innerHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h, false);
    });

    // ===== Render loop =====
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // ===== Global error hook =====
    window.addEventListener("error", (e) => {
      if (e?.message) showError(e.message, `<code>${e.filename || ""}</code> : <code>${e.lineno || ""}</code>`);
    });
  </script>
</body>
</html>
